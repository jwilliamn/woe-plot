import pandas as pd
import numpy as np
import scorecardpy as sc

import traceback
import os

import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages


__all__ = ["WoeReport"]

def plot_bin(binx, title, show_iv, ax, adjust_xlabel, rotation):
    '''
    plot binning of one variable
    
    Params
    ------
    binx: Binning information generated by `woebin`.
    title: Plot title
    show_iv: To show plot
    ax: Axes
    adjust_xlabel: Adjust xlabel to avoid overlapping 
    rotation: Rotatin angle to `adjust_xlabel`
    
    Returns
    ------
    matplotlib fig object
    '''
    # y_right_max
    y_right_max = np.ceil(binx['badprob'].max()*10)
    if y_right_max % 2 == 1: y_right_max=y_right_max+1
    if y_right_max - binx['badprob'].max()*10 <= 0.3: y_right_max = y_right_max+2
    y_right_max = y_right_max/10
    if y_right_max>1 or y_right_max<=0 or y_right_max is np.nan or y_right_max is None: y_right_max=1
    ## y_left_max
    y_left_max = np.ceil(binx['count_distr'].max()*10)/10
    if y_left_max>1 or y_left_max<=0 or y_left_max is np.nan or y_left_max is None: y_left_max=1
    # title
    title_string = binx.loc[0,'variable']+"  (iv:"+str("%.4f" % round(binx.loc[0,'total_iv'],4))+")" if show_iv else binx.loc[0,'variable']
    title_string = title+'-'+title_string if title is not None else title_string
    # param
    ind = np.arange(len(binx.index))    # the x locations for the groups
    width = 0.35       # the width of the bars: can also be len(x) sequence
    ###### plot ###### 
    # create a matplotlib figure, if `ax` hasn't been specified.
    if not ax:
        figsize = (6, 5) #(7.5, 5) 
        fig = plt.figure(figsize=figsize)
        #fig, ax1 = plt.subplots()
        ax1 = fig.gca()
    else:
        ax1 = ax
        fig = ax1.get_figure()
        
    
    ax2 = ax1.twinx()
    # ax1
    p1 = ax1.bar(ind, binx['good_distr'], width, color=(24/254, 192/254, 196/254))
    p2 = ax1.bar(ind, binx['bad_distr'], width, bottom=binx['good_distr'], color=(246/254, 115/254, 109/254))
    for i in ind:
        ax1.text(i, binx.loc[i,'count_distr']*1.02, str("%.1f" % round(binx.loc[i,'count_distr']*100,1))+'%, '+str(binx.loc[i,'count']), ha='center')
    # ax2
    ax2.plot(ind, binx['badprob'], marker='o', color='blue')
    for i in ind:
        ax2.text(i, binx.loc[i,'badprob']*1.02, str("%.1f" % round(binx.loc[i,'badprob']*100,1))+'%', color='blue', ha='center')
    # settings
    ax1.set_ylabel('Bin count distribution')
    ax2.set_ylabel('Bad probability', color='blue')
    ax1.set_yticks(np.arange(0, y_left_max+0.2, 0.2))
    ax2.set_yticks(np.arange(0, y_right_max+0.2, 0.2))
    ax2.tick_params(axis='y', colors='blue')
    plt.xticks(ind, binx['bin'])
    if adjust_xlabel:
        ax1.set_xticklabels(binx['bin'], rotation = rotation)
    plt.title(title_string, loc='left')
    plt.legend((p2[0], p1[0]), ('bad', 'good'), loc='upper right')
    # show plot 
    # plt.show()
    return fig


def woebin_plot2(bins, x=None, title=None, show_iv=True, ax=None, adjust_xlabel=False, rotation=10):
    '''
    WOE Binning Visualization
    ------
    `woebin_plot2` create plots of count distribution and bad probability 
    for each bin. The binning informations are generates by `woebin`.
    
    Params
    ------
    bins: A list or data frame. Binning information generated by `woebin`.
    x: Name of x variables. Default is None. If x is None, then all 
      variables except y are counted as x variables.
    title: String added to the plot title. Default is None.
    show_iv: Logical. Default is True, which means show information value 
      in the plot title.
    ax: plots woes direclty on the axes provided
    adjust_xlabel: Adjust xlabel to avoid overlapping 
    rotation: Rotatin angle to `adjust_xlabel`
    
    Returns
    ------
    dict
        a dict of matplotlib figure objests
        
    Examples
    ------
    import scorecardpy as sc
    import matplotlib.pyplot as plt
    
    # load data
    dat = sc.germancredit()
    
    # Example I
    dt1 = dat[["creditability", "credit.amount"]]
    
    bins1 = sc.woebin(dt1, y="creditability")
    p1 = sc.woebin_plot(bins1)
    plt.show(p1)
    
    # Example II
    bins = sc.woebin(dat, y="creditability")
    plotlist = sc.woebin_plot(bins)
    
    # # save binning plot
    # for key,i in plotlist.items():
    #     plt.show(i)
    #     plt.savefig(str(key)+'.png')
    '''
    xs = x
    # bins concat 
    if isinstance(bins, dict):
        bins = pd.concat(bins, ignore_index=True)
    # good bad distr
    def gb_distr(binx):
        binx['good_distr'] = binx['good']/sum(binx['count'])
        binx['bad_distr'] = binx['bad']/sum(binx['count'])
        return binx
    bins = bins.groupby('variable', group_keys=False).apply(gb_distr)
    # x variable names
    if xs is None: xs = bins['variable'].unique()
    
    # axes provided:
    if ax and (len(bins['variable'].unique())>1):
        print("When axes are provided, bins returned from `woebin` should contain only one variable (not a list)")
    else:
        # plot export
        plotlist = {}
        for i in xs:
            binx = bins[bins['variable'] == i].reset_index(drop=True)
            plotlist[i] = plot_bin(binx, title, show_iv, ax, adjust_xlabel, rotation)
        return plotlist





class ResultInstance:
    """The ResultInstance class is used to store all info necessary to generate the report.
    
    Parameters
    ----------

    Attributes
    ----------
    plot : 
        Plots the data distribution for each variable in the set of features
    save : 
        Saves the data distribution for each variable in the set of features into a pdf file
    """
    
    def __init__(self):
        self.bins = {}
        self.name = 'Woe Report'
        self.feat = []
        self.ax = None 
        self.adjust_xlabel = False 
        self.rotation = 0
        self.data = pd.DataFrame
        self.y = None

    
    def plot(self):
        

        nrow = int(len(self.feat)/2) if len(self.feat)%2 == 0 else int(len(self.feat)/2) + 1
        
        fig, axes = plt.subplots(nrow, 2, figsize=(18, round(6.66*nrow)))
        for i in range(len(self.feat)):
            woebin_plot2(self.bins[self.feat[i]], ax=axes[int(i/2), i%2])
            axes[int(i/2), i%2].set_xlabel(self.feat[i])

        fig.suptitle(self.name, x=0.3, y=0.93, fontsize=24, weight='bold', c='#1eba20')
        fig.text(x=0.19, y=0.903, s='summary', fontsize=15, weight='bold')
        fig.text(x=0.255, y=0.903, s='weight of evidence (woe) binning', fontsize=15, fontstyle='italic', c='#cecbcb', weight='normal')
        fig.text(x=0.50, y=0.903, s='Num features: '+str(len(self.feat)), fontsize=15, fontstyle='italic', weight='regular')
        
        fig1 = plt.gcf()


    
    def save(self, namefile='woeReport.pdf'):

        with PdfPages(namefile) as pdf:

            npages = len(self.feat)//6 if len(self.feat)%6 == 0 else 1 + len(self.feat)//6
            for pg in range(npages):
                var = self.feat[pg*6:pg*6+6]
                nrow = len(var)//2 if len(var)%2 == 0 else 1 + len(var)//2

                fig, axes = plt.subplots(3, 2, figsize=(18, 20))
                for i in range(len(var)):
                    woebin_plot2(self.bins[self.feat[i]], ax=axes[int(i/2), i%2])
                    axes[int(i/2), i%2].set_xlabel(self.feat[i])

                if pg == 0:
                    fig.suptitle(self.name, x=0.3, y=0.93, fontsize=24, weight='bold', c='#1eba20')
                    fig.text(x=0.19, y=0.903, s='summary', fontsize=15, weight='bold')
                    fig.text(x=0.255, y=0.903, s='weight of evidence (woe) binning', fontsize=15, fontstyle='italic', c='#cecbcb', weight='normal')
                    fig.text(x=0.50, y=0.903, s='Num features: '+str(len(self.feat)), fontsize=15, fontstyle='italic', weight='regular')

                pdf.savefig()  # saves the current figure into a pdf page
                plt.close()

        return "Report saved to: " + namefile



class WoeReport:
    """The WoeReport generates report of many variables and has the option 
    to save to a pdf file:

    Parameters
    ----------
    name : str
        Name of the report
    features : List[str]
        A list of features to analyse the drift.
    ax : axes object
        Matplotlib axes object
        Default: None
    adjust_xlabel : bool
        Adjust the xlabel of the plots due to overlapping according to the rotation angle provided 
        in `rotation`
        Options:True, False
        Default: False
    rotation : int
        The rotation angle to adjust the xlabels
        Default: 10

    Attributes
    ----------
    run : **args
        The main attribute to generate the report
    """
    
    def __init__(self, name: str, features: list['str'] | None = None, ax=None, adjust_xlabel=False, rotation=10) -> None:
    
        self.name = name
        self.features = features  # will be overwritten if None
        self.ax = ax  
        self.adjust_xlabel = adjust_xlabel
        self.rotation = rotation
        self.data = None
        self.y = None


    def is_valid(self, data, y):
        valid = False
        if self.features == None:
            self.features = list(data.columns)
            self.features.remove(y)
            self.data = data
            self.y = y
            valid = True
        else:
            data_feat_cols = list(data.columns)
            data_feat_cols.remove(y)
            print(set(self.features).issubset(set(data_feat_cols)))
            if set(self.features).issubset(set(data_feat_cols)):
                self.data = data
                self.y = y
                valid = True
            else: valid = False
                   
        return valid


    def generate(self):
        
        print(f'Generando woe bins ...')
        bins = sc.woebin(self.data, x=self.features, y=self.y, print_info=False)

        results = ResultInstance()
        results.bins = bins
        results.name = self.name
        results.feat = self.features 
        results.ax = self.ax  
        results.adjust_xlabel = self.adjust_xlabel
        results.rotation = self.rotation
        results.data = self.data
        results.y = self.y

        return results
                        
        
    def run(self, data: pd.DataFrame, y: str):
        """Checks, validate, process data and generates the report.

        Parameters
        ----------
        data : DataFrame containing the features + target variable
        y : str
            The name of the target variable
        
        """
        
        if not self.is_valid(data, y):
            print('La lista de features no coincide con las variables en la data')
            res = None
        else:
            res = self.generate()
            print('Woe bins raady!')


        return res
            
        
        
        